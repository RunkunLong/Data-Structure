//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
import java.lang.Math;

public class StringTable {
    
	public int size;
	public int power;
	public int counter;
	public Record[] recordArray;
	
    //
    // Create an empty table big enough to hold maxSize records.
    //
    public StringTable(int maxSize) 
    {
    	int k=0;
    	counter=0;
    	while(Math.pow(2, k)<maxSize){
    		k++;
    	}
    	power=k;
    	size=(int)Math.pow(2, power);
    	this.recordArray=new Record[size];

    }
    
    //
    //Double the size of the original hashtable when necessary
    public void increment()
    {
    	Record transfertable[];
    	transfertable=recordArray;
    	size=2*size;//double the storage space
    	StringTable increment=new StringTable(size);
    	for(int j=0;j<size/2;j++){
    		increment.insert(transfertable[j]);
    	}
    	this.power=increment.power;
    	this.size=increment.size;
    	this.counter=increment.counter;
    	this.recordArray=increment.recordArray;
    	
    	
    	
   }
    
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
    public boolean insert(Record r) 
    { 
    	String pre=r.key;
    	int Key=toHashKey(pre);//change the our key from string to int
    	int h1=baseHash(Key);
    	//System.out.print(h1);
    	int h2=stepHash(Key);
        int p=h1;
        int q=0;
        if(recordArray[p]==null || recordArray[p].key.equals("DELETED")){
        	recordArray[p]=r;
        	System.out.println(recordArray[p].key);
        	recordArray[p].tohashthis=Key;
        	counter++;
        	double LF=counter/size;
        	if(LF>0.25)
        	{
        		this.increment();
        	}
        	return true;
        }
        //
        //the stepHash operation
        //
        while(q<size){
        	p=(p+h2)%(size);
        	if(recordArray[p]==null || recordArray[p].key.equals("DELETED")){
        		recordArray[p]=r;
        		recordArray[p].tohashthis=Key;
        		counter++;
        		double LF=counter/size;
        	 	if(LF>0.25)
            	{
            		this.increment();
            	}
        	 	return true;
        	}
        	q++;
        }
    	//System.out.print("Hi");
	return false; 
    }
    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	String removekey=r.key;
    	Record search=find(removekey);
    	if(search!=null){
    		find(removekey).tohashthis=0;
    		find(removekey).key="DELETED";
    		//System.out.print(find(removekey).key);
    				
    		counter--;
    	}
    	
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int hashKey = toHashKey(key);
     	int h1 = baseHash(hashKey);
        int h2 = stepHash(hashKey);
        
      //initial hash function value
        int p = h1;
        int q = 0;
        while(recordArray[p]!=null && q<size){
         		if(recordArray[p].key.equals(key)){
         			return recordArray[p]; //if record is found, return it.
         			//System.out.print(recordArray[p].key);
         		}
         		p=(p+h2)%(size);
         		q++;
         }
        /*
        while(recordArray[p]!=null && q<size){
        	p=(p+h2)%(size);
        	if(recordArray[p]==null ){
        		return null;
        	}
        	if(recordArray[p].key.equals(key)){
        		return recordArray[p];
        	}
        	q++;
        }
        */
    
	return null; 
    }
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s)
    {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
    	double A=(Math.sqrt(5.0)-1)/2;
    	int h1=(int)Math.floor(size*(A*hashKey-Math.floor(A*hashKey)));
    	return h1;

    }
    
    int stepHash(int hashKey)
    {
    	double A = (Math.sqrt(7.0)-1)/2;
     	int h2 = (int)Math.floor(size*(A*hashKey-Math.floor(A*hashKey)));
     	if(h2%2==0) h2 = h2+1;  //if h2 is even, add 1 and make it odd
     	return h2;
    }
}
